<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>D3D12 Memory Allocator: Optimal resource allocation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">D3D12 Memory Allocator
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">D3D12 Memory Allocator</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Optimal resource allocation</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This library tries to automatically make optimal choices for the resources you create, so you don't need to care about them. There are some advanced features of Direct3D 12 that you may use to optimize your memory management. There are also some settings in D3D12MA that you may change to alter its default behavior. This page provides miscellaneous advice about features of D3D12 and D3D12MA that are non-essential, but may improve the stability or performance of your app.</p>
<h1><a class="anchor" id="optimal_allocation_avoiding_running_out_of_memory"></a>
Avoiding running out of memory</h1>
<p>When trying to allocate more memory than available in the current heap (e.g., video memory on the graphics card, system memory), one of few bad things can happen:</p>
<ul>
<li>The allocation (resource creation) function call can fail with <code>HRESULT</code> value other than <code>S_OK</code>.</li>
<li>The allocation may succeed, but take long time (even a significant fraction of a second).</li>
<li>Some resources are automatically demoted from video memory to system memory, degrading the app performance.</li>
<li>Even a crash of the entire graphics driver can happen, resulting in the D3D12 "device removal", which is usually catastrophic for the application.</li>
</ul>
<p>Unfortunately, there is no way to be 100% protected against memory overcommitment. The best approach is to avoid allocating too much memory.</p>
<p>The full capacity of the memory can be queried using function <a class="el" href="class_d3_d12_m_a_1_1_allocator.html#a434ae3147209953253da26687bfd62dc" title="Returns total amount of memory of specific segment group, in bytes.">D3D12MA::Allocator::GetMemoryCapacity</a>. However, it is not recommended, because the amount of memory available to the application is typically smaller than the full capacity, as some portion of it is reserved by the operating system or used by other processes.</p>
<p>Because of this, the recommended way of fetching the <b>memory budget</b> available to the application is using function <a class="el" href="class_d3_d12_m_a_1_1_allocator.html#a1ac113daec5f6ef28ecb1786cf544144" title="Retrieves information about current memory usage and budget.">D3D12MA::Allocator::GetBudget</a>. Preventing value <a class="el" href="struct_d3_d12_m_a_1_1_budget.html#a77a8c9e32d6602f95b7d1c285cddd253" title="Estimated current memory usage of the program.">D3D12MA::Budget::UsageBytes</a> from exceeding the <a class="el" href="struct_d3_d12_m_a_1_1_budget.html#a326515f08d89ee2e31dcfdd5c1e8ac71" title="Estimated amount of memory available to the program.">D3D12MA::Budget::BudgetBytes</a> is probably the best we can do in trying to avoid the consequences of over-commitment. For more information, see also: <a class="el" href="statistics.html">Statistics</a>.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="struct_d3_d12_m_a_1_1_budget.html">D3D12MA::Budget</a> videoMemBudget = {};</div>
<div class="line">allocator-&gt;GetBudget(&amp;videoMemBudget, NULL);</div>
<div class="line"> </div>
<div class="line">UINT64 freeBytes = videoMemBudget.<a class="code hl_variable" href="struct_d3_d12_m_a_1_1_budget.html#a326515f08d89ee2e31dcfdd5c1e8ac71">BudgetBytes</a> - videoMemBudget.<a class="code hl_variable" href="struct_d3_d12_m_a_1_1_budget.html#a77a8c9e32d6602f95b7d1c285cddd253">UsageBytes</a>;</div>
<div class="line">gameStreamingSystem-&gt;SetAvailableFreeMemory(freeBytes);</div>
<div class="ttc" id="astruct_d3_d12_m_a_1_1_budget_html"><div class="ttname"><a href="struct_d3_d12_m_a_1_1_budget.html">D3D12MA::Budget</a></div><div class="ttdoc">Statistics of current memory usage and available budget for a specific memory segment group.</div><div class="ttdef"><b>Definition</b> D3D12MemAlloc.h:474</div></div>
<div class="ttc" id="astruct_d3_d12_m_a_1_1_budget_html_a326515f08d89ee2e31dcfdd5c1e8ac71"><div class="ttname"><a href="struct_d3_d12_m_a_1_1_budget.html#a326515f08d89ee2e31dcfdd5c1e8ac71">D3D12MA::Budget::BudgetBytes</a></div><div class="ttdeci">UINT64 BudgetBytes</div><div class="ttdoc">Estimated amount of memory available to the program.</div><div class="ttdef"><b>Definition</b> D3D12MemAlloc.h:497</div></div>
<div class="ttc" id="astruct_d3_d12_m_a_1_1_budget_html_a77a8c9e32d6602f95b7d1c285cddd253"><div class="ttname"><a href="struct_d3_d12_m_a_1_1_budget.html#a77a8c9e32d6602f95b7d1c285cddd253">D3D12MA::Budget::UsageBytes</a></div><div class="ttdeci">UINT64 UsageBytes</div><div class="ttdoc">Estimated current memory usage of the program.</div><div class="ttdef"><b>Definition</b> D3D12MemAlloc.h:486</div></div>
</div><!-- fragment --><dl class="section user"><dt>Implementation detail</dt><dd>DXGI interface offers function <code>IDXGIAdapter3::QueryVideoMemoryInfo</code> that queries the current memory usage and budget. This library automatically makes use of it when available (when you use recent enough version of the DirectX SDK). If not, it falls back to estimating the usage and budget based on the total amount of the allocated memory and 80% of the full memory capacity, respectively.</dd></dl>
<dl class="section user"><dt>Implementation detail</dt><dd>Allocating large heaps and creating placed resources in them is one of the main features of this library. However, if allocating new such block would exceed the budget, it will automatically prefer creating the resource as committed to have exactly the right size, which can lower the chance of getting into trouble in case of over-commitment.</dd></dl>
<p>When creating non-essential resources, you can use <a class="el" href="namespace_d3_d12_m_a.html#abbad31a7e0b3d09d77f3fb704b77645eab374417c1f22a833ead268a6c21424e6">D3D12MA::ALLOCATION_FLAG_WITHIN_BUDGET</a>. Then, in case the allocation would exceed the budget, the library will return failure from the function without attempting to allocate the actual D3D12 memory.</p>
<p>It may also be a good idea to support failed resource creation. For non-essential resources, when function <a class="el" href="class_d3_d12_m_a_1_1_allocator.html#aa37d6b9fe8ea0864f7a35b9d68e8345a" title="Allocates memory and creates a D3D12 resource (buffer or texture). This is the main allocation functi...">D3D12MA::Allocator::CreateResource</a> fails with a result other than <code>S_OK</code>, it is worth implementing some way of recovery instead of terminating or crashing the entire app.</p>
<h1><a class="anchor" id="optimal_allocation_allocation_Performance"></a>
Allocation performance</h1>
<p>Creating D3D12 resources (buffers and textures) can be a time-consuming operation. The duration can be unpredictable, spanning from a small fraction of a millisecond to a significant fraction of a second. Thus, it is recommended to allocate all the memory and create all the resources needed upfront rather than doing it during application runtime. For example, a video game can try to create its resources on startup or when loading a new level. Of course, is is not always possible. For example, open-world games may require loading and unloading some graphical assets in the background (often called "streaming").</p>
<p>Creating and releasing D3D12 resources <b>on a separate thread</b> in the background may help. Both <code>ID3D12Device</code> and <a class="el" href="class_d3_d12_m_a_1_1_allocator.html" title="Represents main object of this library initialized for particular ID3D12Device.">D3D12MA::Allocator</a> objects are thread-safe, synchronized internally. However, cases were observed where resource creation calls like <code>ID3D12Device::CreateCommittedResource</code> were blocking other D3D12 calls like <code>ExecuteCommandLists</code> or <code>Present</code> somewhere inside the graphics driver, so hitches can happen even when using multithreading.</p>
<p>The most expensive part is typically <b>the allocation of a new D3D12 memory heap</b>. This library tackles this problem by automatically allocating large heaps (64 MB by default) and creating resources as placed inside of them. When a new requested resource can be placed in a free space of an existing heap and doesn't require allocating a new heap, this operation is typically much faster, as it only requires creating a new <code>ID3D12Resource</code> object and not allocating new memory. This is the main benefit of using D3D12MA compared to the naive approach of using Direct3D 12 directly and creating each resource as committed with <code>CreateCommittedResource</code>, which would result in a separate allocation of an implicit heap every time.</p>
<p>When <b>a large number of small buffers</b> needs to be created, the overhead of creating even just separate <code>ID3D12Resource</code> objects can be significant. It can be avoided by creating one or few larger buffers and manually sub-allocating parts of them for specific needs. This library can also help with it. See section "Sub-allocating buffers" below.</p>
<dl class="section user"><dt>Implementation detail</dt><dd>The CPU performance overhead of using this library is low. It uses a high-quality allocation algorithm called Two-Level Segregated Fit (TLSF), which in most cases can find a free place for a new allocation in few steps. The library also doesn't perform too many CPU heap allocations. In may cases, the allocation happens with 0 new CPU heap allocations performed by the library. Even the creation of a <a class="el" href="class_d3_d12_m_a_1_1_allocation.html" title="Represents single memory allocation.">D3D12MA::Allocation</a> object itself doesn't typically feature an CPU allocation, because these objects are returned out of a dedicated memory pool.</dd></dl>
<p>Another reason for the slowness of D3D12 memory allocation is the guarantee that the <b>newly allocated memory is filled with zeros</b>. When creating and destroying resources placed in an existing heap, this overhead is not present, and the memory is not zeroed - it may contain random data left by the resource previously allocated in that place. In recent versions of the DirectX 12 SDK, clearing the memory of the newly created D3D12 heaps can also be disabled for the improved performance. D3D12MA can use this feature when:</p>
<ul>
<li><a class="el" href="namespace_d3_d12_m_a.html#ad5ae5a5e42b878f2e18ab5d1fbfb9916ae7dc7ab9168148281ebfe1586f554335">D3D12MA::ALLOCATOR_FLAG_DEFAULT_POOLS_NOT_ZEROED</a> is used during the creation of the main allocator object.</li>
<li><code>D3D12_HEAP_FLAG_CREATE_NOT_ZEROED</code> is passed to <a class="el" href="struct_d3_d12_m_a_1_1_p_o_o_l___d_e_s_c.html#a3795956e4fbfe7c3a23546e02e5d28dc" title="Heap flags to be used when allocating heaps of this pool.">D3D12MA::POOL_DESC::HeapFlags</a> during the creation of a custom pool.</li>
</ul>
<p>It is recommended to always use these flags. The downside is that when the memory is not filled with zeros, while you don't properly clear it or otherwise initialize its content before use (which is required by D3D12), you may observe incorrect behavior. This problem mostly affects render-target and depth-stencil textures.</p>
<p>When an allocation needs to be made in a performance-critical code, you can use <a class="el" href="namespace_d3_d12_m_a.html#abbad31a7e0b3d09d77f3fb704b77645eaa3ded8847563c24b4522af0586dbd2cb">D3D12MA::ALLOCATION_FLAG_STRATEGY_MIN_TIME</a>. In influences multiple heuristics inside the library to prefer faster allocation at the expense of possibly less optimal placement in the memory.</p>
<p>If the resource to be created is non-essential, while the performance is paramount, you can also use <a class="el" href="namespace_d3_d12_m_a.html#abbad31a7e0b3d09d77f3fb704b77645ea9a52c6ae694eadcd20896091e77c0628">D3D12MA::ALLOCATION_FLAG_NEVER_ALLOCATE</a>. It will create the resource only if it can be placed inside and existing memory heap and return failure from the function if a new heap would need to be allocated, which should guarantee good performance of such function call.</p>
<h1><a class="anchor" id="optimal_allocation_suballocating_buffers"></a>
Sub-allocating buffers</h1>
<p>When a large number of small buffers needs to be created, the overhead of creating separate <code>ID3D12Resource</code> objects can be significant. It can also cause a significant waste of memory, as placed buffers need to be aligned to <code>D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT</code> = 64 KB by default. These problems can be avoided by creating one or few larger buffers and manually sub-allocating parts of them for specific needs.</p>
<p>It requires implementing a custom allocator for the data inside the buffer and using offsets to individual regions. When all the regions can be allocated linearly and freed all at once, implementing such allocator is trivial. When every region has the same size, implementing an allocator is also quite simple when using a "free list" algorithm. However, when regions can have different sizes and can be allocated and freed in random order, it requires a full allocation algorithm. D3D12MA can help with it by exposing its core allocation algorithm for custom usages. For more details and example code, see chapter: <a class="el" href="virtual_allocator.html">Virtual allocator</a>. It can be used for all the cases mentioned above without too much performance overhead, because the <a class="el" href="struct_d3_d12_m_a_1_1_virtual_allocation.html" title="Represents single memory allocation done inside VirtualBlock.">D3D12MA::VirtualAllocation</a> object is just a lightweight handle.</p>
<p>When sub-allocating a buffer, you need to remember to explicitly request proper alignment required for each region. For example, data used as a constant buffer must be aligned to <code>D3D12_CONSTANT_BUFFER_DATA_PLACEMENT_ALIGNMENT</code> = 256 B.</p>
<h1><a class="anchor" id="optimal_allocation_residency_priority"></a>
Residency priority</h1>
<p>When too much video memory is allocated, one of the things that can happen is the system demoting some heaps to the system memory. Moving data between memory pools or reaching out directly to the system memory through PCI Express bus can have large performance overhead, which can slow down the application, or even make the game unplayable any more. Unfortunately, it is not possible to fully control or prevent this demotion. Best thing to do is avoiding memory over-commitment. For more information, see section "Avoiding running out of memory" above.</p>
<p>Recent versions of DirectX 12 SDK offer function <code>ID3D12Device1::SetResidencyPriority</code> that sets a hint about the priority of a resource - how important it is to stay resident in the video memory. Setting the priority happens at the level of an entire memory heap. D3D12MA offers an interface to set this priority in form of <a class="el" href="struct_d3_d12_m_a_1_1_p_o_o_l___d_e_s_c.html#a2e6074af8c8ff7b957fe8d4b5036a5e6" title="Residency priority to be set for all allocations made in this pool. Optional.">D3D12MA::POOL_DESC::ResidencyPriority</a> parameter. It affects all allocations made out of the custom pool created with it, both placed inside large heaps and created as committed.</p>
<p>It is recommended to create a custom pool for the purpose of using high residency priority of all resources that are critical for the performance, especially those that are written by the GPU, like render-target, depth-stencil textures, UAV textures and buffers. It is also worth creating them as committed, so that each one will have its own implicit heap. This can minimize the chance that an entire large heap is demoted to system memory, degrading performance of all the resources placed in it.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="struct_d3_d12_m_a_1_1_c_p_o_o_l___d_e_s_c.html">D3D12MA::CPOOL_DESC</a> poolDesc = <a class="code hl_struct" href="struct_d3_d12_m_a_1_1_c_p_o_o_l___d_e_s_c.html">D3D12MA::CPOOL_DESC</a>{</div>
<div class="line">    D3D12_HEAP_TYPE_DEFAULT,</div>
<div class="line">    <a class="code hl_define" href="_d3_d12_mem_alloc_8h.html#ac3d50f134ad24c58df4a934b87847653">D3D12MA_RECOMMENDED_HEAP_FLAGS</a> | D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS };</div>
<div class="line">poolDesc.<a class="code hl_variable" href="struct_d3_d12_m_a_1_1_p_o_o_l___d_e_s_c.html#a2e6074af8c8ff7b957fe8d4b5036a5e6">ResidencyPriority</a> = D3D12_RESIDENCY_PRIORITY_HIGH; <span class="comment">// !!!</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_d3_d12_m_a_1_1_pool.html">D3D12MA::Pool</a>* pool;</div>
<div class="line">HRESULT hr = allocator-&gt;CreatePool(&amp;poolDesc, &amp;pool);</div>
<div class="line"><span class="comment">// Check hr...</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="struct_d3_d12_m_a_1_1_c_a_l_l_o_c_a_t_i_o_n___d_e_s_c.html">D3D12MA::CALLOCATION_DESC</a> allocDesc = <a class="code hl_struct" href="struct_d3_d12_m_a_1_1_c_a_l_l_o_c_a_t_i_o_n___d_e_s_c.html">D3D12MA::CALLOCATION_DESC</a>{</div>
<div class="line">    pool,</div>
<div class="line">    ALLOCATION_FLAG_COMMITTED }; <span class="comment">// !!!</span></div>
<div class="line"> </div>
<div class="line">CD3DX12_RESOURCE_DESC resDesc = CD3DX12_RESOURCE_DESC::Buffer(</div>
<div class="line">    1048576); <span class="comment">// Requested buffer size.</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_d3_d12_m_a_1_1_allocation.html">D3D12MA::Allocation</a>* alloc;</div>
<div class="line">hr = allocator-&gt;CreateResource(&amp;allocDesc, &amp;resDesc, D3D12_RESOURCE_STATE_COMMON,</div>
<div class="line">    NULL, &amp;alloc, IID_NULL, NULL);</div>
<div class="line"><span class="comment">// Check hr...</span></div>
<div class="ttc" id="a_d3_d12_mem_alloc_8h_html_ac3d50f134ad24c58df4a934b87847653"><div class="ttname"><a href="_d3_d12_mem_alloc_8h.html#ac3d50f134ad24c58df4a934b87847653">D3D12MA_RECOMMENDED_HEAP_FLAGS</a></div><div class="ttdeci">#define D3D12MA_RECOMMENDED_HEAP_FLAGS</div><div class="ttdoc">Set of flags recommended for use in D3D12MA::POOL_DESC::HeapFlags for optimal performance.</div><div class="ttdef"><b>Definition</b> D3D12MemAlloc.h:136</div></div>
<div class="ttc" id="aclass_d3_d12_m_a_1_1_allocation_html"><div class="ttname"><a href="class_d3_d12_m_a_1_1_allocation.html">D3D12MA::Allocation</a></div><div class="ttdoc">Represents single memory allocation.</div><div class="ttdef"><b>Definition</b> D3D12MemAlloc.h:523</div></div>
<div class="ttc" id="aclass_d3_d12_m_a_1_1_pool_html"><div class="ttname"><a href="class_d3_d12_m_a_1_1_pool.html">D3D12MA::Pool</a></div><div class="ttdoc">Custom memory pool.</div><div class="ttdef"><b>Definition</b> D3D12MemAlloc.h:992</div></div>
<div class="ttc" id="astruct_d3_d12_m_a_1_1_c_a_l_l_o_c_a_t_i_o_n___d_e_s_c_html"><div class="ttname"><a href="struct_d3_d12_m_a_1_1_c_a_l_l_o_c_a_t_i_o_n___d_e_s_c.html">D3D12MA::CALLOCATION_DESC</a></div><div class="ttdoc">Helper structure that helps with complete and conscise initialization of the D3D12MA::ALLOCATION_DESC...</div><div class="ttdef"><b>Definition</b> D3D12MemAlloc.h:1659</div></div>
<div class="ttc" id="astruct_d3_d12_m_a_1_1_c_p_o_o_l___d_e_s_c_html"><div class="ttname"><a href="struct_d3_d12_m_a_1_1_c_p_o_o_l___d_e_s_c.html">D3D12MA::CPOOL_DESC</a></div><div class="ttdoc">Helper structure that helps with complete and conscise initialization of the D3D12MA::POOL_DESC struc...</div><div class="ttdef"><b>Definition</b> D3D12MemAlloc.h:1695</div></div>
<div class="ttc" id="astruct_d3_d12_m_a_1_1_p_o_o_l___d_e_s_c_html_a2e6074af8c8ff7b957fe8d4b5036a5e6"><div class="ttname"><a href="struct_d3_d12_m_a_1_1_p_o_o_l___d_e_s_c.html#a2e6074af8c8ff7b957fe8d4b5036a5e6">D3D12MA::POOL_DESC::ResidencyPriority</a></div><div class="ttdeci">D3D12_RESIDENCY_PRIORITY ResidencyPriority</div><div class="ttdoc">Residency priority to be set for all allocations made in this pool. Optional.</div><div class="ttdef"><b>Definition</b> D3D12MemAlloc.h:980</div></div>
</div><!-- fragment --><p>When you have a committed allocation created, you can also set the residency priority of its resource using the D3D12 function:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_d3_d12_m_a_1_1_allocation.html">D3D12MA::Allocation</a>* committedAlloc = ...</div>
<div class="line">ID3D12Pageable* res = committedAlloc-&gt;<a class="code hl_function" href="class_d3_d12_m_a_1_1_allocation.html#ad00308118252f82d8f803c623c67bf18">GetResource</a>();</div>
<div class="line">D3D12_RESIDENCY_PRIORITY priority = D3D12_RESIDENCY_PRIORITY_HIGH;</div>
<div class="line">device1-&gt;SetResidencyPriority(1, &amp;res, &amp;priority);</div>
<div class="ttc" id="aclass_d3_d12_m_a_1_1_allocation_html_ad00308118252f82d8f803c623c67bf18"><div class="ttname"><a href="class_d3_d12_m_a_1_1_allocation.html#ad00308118252f82d8f803c623c67bf18">D3D12MA::Allocation::GetResource</a></div><div class="ttdeci">ID3D12Resource * GetResource() const</div><div class="ttdoc">Returns D3D12 resource associated with this object.</div><div class="ttdef"><b>Definition</b> D3D12MemAlloc.h:552</div></div>
</div><!-- fragment --><p>Note this is not the same as explicit eviction controlled using <code>ID3D12Device::Evict</code> and <code>MakeResident</code> functions. Resources evicted explicitly are illegal to access until they are made resident again, while the demotion described here happens automatically and only slows down the execution.</p>
<h1><a class="anchor" id="optimal_allocation_gpu_upload_heap"></a>
GPU upload heap</h1>
<p>Direct3D 12 offers a fixed set of memory heap types:</p>
<ul>
<li><code>D3D12_HEAP_TYPE_DEFAULT</code>: Represents the video memory. It is available and fast to access for the GPU. It should be used for all resources that are written by the GPU (like render-target and depth-stencil textures, UAV) and resources that are frequently read by the GPU (like textures intended for sampling, vertex, index, and constant buffers).</li>
<li><code>D3D12_HEAP_TYPE_UPLOAD</code>: Represents the system memory that is uncached and write-combined. It can be mapped and accessed by the CPU code using a pointer. It supports only buffers, not textures. It is intended for "staging buffers" that are filled by the CPU code and then used as a source of copy operations to the <code>DEFAULT</code> heap. It can also be accessed directly by the GPU - shaders can read from buffers created in this memory.</li>
<li><code>D3D12_HEAP_TYPE_READBACK</code>: Represents the system memory that is cached. It is intended for buffers used as a destination of copy operations from the <code>DEFAULT</code> heap.</li>
</ul>
<p>Note that in systems with a discrete graphics card, access to system memory is fast from the CPU code (like the C++ code mapping D3D12 buffers and accessing them through a pointer), while access to the video memory is fast from the GPU code (like shaders reading and writing buffers and textures). Any copy operation or direct access between these memory heap types happens through PCI Express bus, which can be relatively slow.</p>
<p>Modern systems offer a feature called <b>Resizable BAR (ReBAR)</b> that gives the CPU direct access to the full video memory. To be available, this feature needs to be supported by the whole hardware-software environment, including:</p>
<ul>
<li>Supporting motherboard and its UEFI.</li>
<li>Supporting graphics card and its graphics driver.</li>
<li>Supporting operating system.</li>
<li>The feature needs to be enabled in the UEFI settings. It is typically called "Above 4G Decoding" and "Resizable Bar".</li>
</ul>
<p>Recent versions of DirectX 12 SDK give access to this feature in form of a new, 4th memory pool: <code>D3D12_HEAP_TYPE_GPU_UPLOAD</code>. Resources created in it behave logically similar to the <code>D3D12_HEAP_TYPE_UPLOAD</code> heap:</p>
<ul>
<li>They support mapping and direct access from the CPU code through a pointer.</li>
<li>The mapped memory is uncached and write-combined, so it should be only written sequentially (e.g., number-by-number or using <code>memcpy</code>). It shouldn't be accessed randomly or read, because it is extremely slow for uncached memory.</li>
<li>Only buffers are supported.</li>
<li>Those buffers can be used as a source of copy operations or directly accessed by the GPU.</li>
</ul>
<p>The main difference is that resources created in the new <code>D3D12_HEAP_TYPE_GPU_UPLOAD</code> are placed in the video memory, while resources created in the old <code>D3D12_HEAP_TYPE_UPLOAD</code> are placed in the system memory. This implies which budgets are consumed by new resources allocated in those heaps. This also implies which operations involve transferring data through the PCI Express bus.</p>
<ul>
<li>As <code>D3D12_HEAP_TYPE_UPLOAD</code> uses the system memory, writes from the CPU code through a mapped pointer are faster, while copies or direct access from the GPU are slower because they need to go through PCIe.</li>
<li>As the new <code>D3D12_HEAP_TYPE_GPU_UPLOAD</code> uses the video memory, copies or direct access from the GPU are faster, while writes from the CPU code through a mapped pointer can be slower, because they need to go through PCIe. For maximum performance of copy operations from this heap, a graphics or compute queue should be used, not a copy queue.</li>
</ul>
<p>GPU Upload Heap can be used for performance optimization of some resources that need to be written by the CPU and read by the GPU. It can be beneficial especially for resources that need to change frequently (often called "dynamic").</p>
<p>D3D12MA supports GPU upload heap when recent enough version of DirectX 12 SDK is used and when the current system supports it. The support can be queried using function <a class="el" href="class_d3_d12_m_a_1_1_allocator.html#a3f3fd1e88cf2cd02257fe272e08a273c" title="Returns true if GPU Upload Heaps are supported on the current system.">D3D12MA::Allocator::IsGPUUploadHeapSupported()</a>. When it returns <code>TRUE</code>, you can create resources using <code>D3D12_HEAP_TYPE_GPU_UPLOAD</code>. You can also just try creating such resource. Example:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="struct_d3_d12_m_a_1_1_c_a_l_l_o_c_a_t_i_o_n___d_e_s_c.html">D3D12MA::CALLOCATION_DESC</a> allocDesc = <a class="code hl_struct" href="struct_d3_d12_m_a_1_1_c_a_l_l_o_c_a_t_i_o_n___d_e_s_c.html">D3D12MA::CALLOCATION_DESC</a>{</div>
<div class="line">    D3D12_HEAP_TYPE_GPU_UPLOAD }; <span class="comment">// !!!</span></div>
<div class="line"> </div>
<div class="line">CD3DX12_RESOURCE_DESC resDesc = CD3DX12_RESOURCE_DESC::Buffer(</div>
<div class="line">    1048576); <span class="comment">// Requested buffer size.</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_d3_d12_m_a_1_1_allocation.html">D3D12MA::Allocation</a>* alloc;</div>
<div class="line">ID3D12Resource* res;</div>
<div class="line">hr = allocator-&gt;CreateResource(&amp;allocDesc, &amp;resDesc, D3D12_RESOURCE_STATE_COMMON,</div>
<div class="line">    NULL, &amp;alloc, IID_PPV_ARGS(&amp;res));</div>
<div class="line"><span class="keywordflow">if</span>(SUCCEEDED(hr))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Fast path for data upload.</span></div>
<div class="line"> </div>
<div class="line">    D3D12_RANGE emptyRange = {0, 0};</div>
<div class="line">    <span class="keywordtype">void</span>* mappedPtr = NULL;</div>
<div class="line">    hr = res-&gt;Map(0, &amp;emptyRange, &amp;mappedPtr);</div>
<div class="line">    memcpy(mappedPtr, srcData, 1048576);</div>
<div class="line">    res-&gt;Unmap(0, NULL); <span class="comment">// Optional. You can leave it persistently mapped.</span></div>
<div class="line"> </div>
<div class="line">    D3D12_GPU_VIRTUAL_ADDRESS gpuva = res-&gt;GetGPUVirtualAddress();</div>
<div class="line">    <span class="comment">// Use gpuva to access the buffer on the GPU...</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span>(hr == E_NOTIMPL)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// GPU Upload Heap not supported in this system.</span></div>
<div class="line">    <span class="comment">// Fall back to creating a staging buffer in UPLOAD and another copy in DEFAULT.</span></div>
<div class="line">    </div>
<div class="line">    allocDesc.<a class="code hl_variable" href="struct_d3_d12_m_a_1_1_a_l_l_o_c_a_t_i_o_n___d_e_s_c.html#aa46b3c0456e5a23edef3328607ebf4d7">HeapType</a> = D3D12_HEAP_TYPE_UPLOAD;</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">    <span class="comment">// Some other error code e.g., out of memory...</span></div>
<div class="ttc" id="astruct_d3_d12_m_a_1_1_a_l_l_o_c_a_t_i_o_n___d_e_s_c_html_aa46b3c0456e5a23edef3328607ebf4d7"><div class="ttname"><a href="struct_d3_d12_m_a_1_1_a_l_l_o_c_a_t_i_o_n___d_e_s_c.html#aa46b3c0456e5a23edef3328607ebf4d7">D3D12MA::ALLOCATION_DESC::HeapType</a></div><div class="ttdeci">D3D12_HEAP_TYPE HeapType</div><div class="ttdoc">The type of memory heap where the new allocation should be placed.</div><div class="ttdef"><b>Definition</b> D3D12MemAlloc.h:347</div></div>
</div><!-- fragment --><h1><a class="anchor" id="optimal_allocation_committed_vs_placed"></a>
Committed versus placed resources</h1>
<p>When using D3D12 API directly, there are 3 ways of creating resources:</p>
<ol type="1">
<li><b>Committed</b>, using function <code>ID3D12Device::CreateCommittedResource</code>. It creates the resource with its own memory heap, which is called an "implicit heap" and cannot be accessed directly.</li>
<li><b>Placed</b>, using function <code>ID3D12Device::CreatePlacedResource</code>. A <code>ID3D12Heap</code> needs to be created beforehand using <code>ID3D12Device::CreateHeap</code>. Then, the resource can be created as placed inside the heap at a specific offset.</li>
<li><b>Reserved</b>, using function <code>ID3D12Device::CreateReservedResource</code>. This library doesn't support them directly.</li>
</ol>
<p>A naive solution would be to create all the resources as committed. It works, because in D3D12 there is no strict limit on the number of resources or heaps that can be created. However, there are certain advantages and disadvantages of using committed versus placed resources:</p>
<ul>
<li>The biggest advantage of using placed resources is the allocation performance. Once a heap is allocated, creating and releasing resources placed in it can be much faster than creating them as committed, which would involve allocating a new heap for each resource.<ul>
<li>Using large number of small heaps can put an extra burden on the software stack, including D3D12 runtime, graphics driver, operating system, and developer tools like Radeon Memory Visualizer (RMV).</li>
</ul>
</li>
<li>The advantage of committed resources is that their implicit heaps have exactly the right size, while creating resources as placed inside larger heaps can lead to some memory wasted because:<ul>
<li>Some part of the allocated heap memory is unused.</li>
<li>After placed resources of various sizes are created and released in random order, gaps between remaining resources can be too small to fit new allocations. This is also known as "fragmentation". A solution to this problem is implementing <a class="el" href="defragmentation.html">Defragmentation</a>.</li>
<li>The alignment required by placed resources can leave gaps between them, while the driver can pack individual committed resources better. For details, see section "Resource alignment" below.</li>
</ul>
</li>
<li>The advantage of committed resources is that they are always created with a new heap, which is initialized with zeros. When a resource is created as placed, the memory may contain random data left by the resource previously allocated in that place. When the memory is not filled with zeros, while you don't properly clear it or otherwise initialize its content before use (which is required by D3D12), you may observe incorrect behavior. On the other hand, using committed resources and having every new resource filled with zeros can leave this kind of bugs undetected.</li>
<li>Manual eviction with <code>ID3D12Device::Evict</code> and <code>MakeResident</code> functions work at the level of the entire heap, and so does <code>ID3D12Device1::SetResidencyPriority</code>, so creating resources as committed allows more fine-grained control over the eviction and residency priority of individual resources.</li>
<li>The advantage of placed resources is that they can be created in a region of a heap overlapping with some other resources. This approach is commonly called "aliasing". It can save memory, but it needs careful control over the resources that overlap in memory to make sure they are not used at the same time, there is an aliasing barrier issued between their usage, and the resource used after aliasing is correctly cleared every time. Committed resources don't offer this possibility, because every committed resource has its own exclusive memory heap. For more information, see chapter <a class="el" href="resource_aliasing.html">Resource aliasing (overlap)</a>.</li>
</ul>
<p>When creating resources with the help of D3D12MA using function <a class="el" href="class_d3_d12_m_a_1_1_allocator.html#aa37d6b9fe8ea0864f7a35b9d68e8345a" title="Allocates memory and creates a D3D12 resource (buffer or texture). This is the main allocation functi...">D3D12MA::Allocator::CreateResource</a>, you typically don't need to care about all this. The library automatically makes the choice of creating the new resource as committed or placed. However, in cases when you need the information or the control over this choice between committed and placed, the library offers facilities to do that, described below.</p>
<dl class="section user"><dt>Implementation detail</dt><dd>D3D12MA creates large heaps (default size is 64 MB) and creates resources as placed in them. However, it may decide that it is required or preferred to create the specific resource as committed for many reasons, including:<ul>
<li>When the resource is large (larger than half of the default heap size).</li>
<li>When allocating an entire new heap would exceed the current budget or when we are already over the budget.</li>
<li>When the resource is a very small buffer. Placed buffers need to be aligned to 64 KB by default, while creating them as committed can allow the driver to pack them better. This heuristics can be disabled for an individual resource by using <a class="el" href="namespace_d3_d12_m_a.html#abbad31a7e0b3d09d77f3fb704b77645eaa3ded8847563c24b4522af0586dbd2cb">D3D12MA::ALLOCATION_FLAG_STRATEGY_MIN_TIME</a> and for the entire allocator by using <a class="el" href="namespace_d3_d12_m_a.html#ad5ae5a5e42b878f2e18ab5d1fbfb9916a15c1ba5fbc182ac927b3011e23e74a72">D3D12MA::ALLOCATOR_FLAG_DONT_PREFER_SMALL_BUFFERS_COMMITTED</a>.</li>
<li>When the resource uses non-standard flags specified via <a class="el" href="struct_d3_d12_m_a_1_1_a_l_l_o_c_a_t_i_o_n___d_e_s_c.html#a97878838f976b2d1e6b1a76881035690" title="Additional heap flags to be used when allocating memory.">D3D12MA::ALLOCATION_DESC::ExtraHeapFlags</a>.</li>
</ul>
</dd></dl>
<p><b>You can check whether an allocation was created as a committed resource</b> by checking if its heap is null. Committed resources have an implicit heap that is not directly accessible.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> isCommitted = allocation-&gt;GetHeap() == NULL;</div>
</div><!-- fragment --><p><b>You can request a new resource to be created as committed</b> by using <a class="el" href="namespace_d3_d12_m_a.html#abbad31a7e0b3d09d77f3fb704b77645ea661a5472dba3dcecc5a2cc92afd25675">D3D12MA::ALLOCATION_FLAG_COMMITTED</a>. Note that committed resources can also be created out of <a class="el" href="custom_pools.html">Custom memory pools</a>.</p>
<p>You can also request all resources to be created as committed globally for the entire allocator by using <a class="el" href="namespace_d3_d12_m_a.html#ad5ae5a5e42b878f2e18ab5d1fbfb9916a068863dc0538ff4ea153b046b31e94fb">D3D12MA::ALLOCATOR_FLAG_ALWAYS_COMMITTED</a>. However, this contradicts the main purpose of using this library. It can also prevent certain other features of the library to be used. This flag should be used only for debugging purposes.</p>
<p>You can create a custom pool with an explicit block size by specifying non-zero <a class="el" href="struct_d3_d12_m_a_1_1_p_o_o_l___d_e_s_c.html#af7284cc51a8ed5b551075584256de23c" title="Size of a single heap (memory block) to be allocated as part of this pool, in bytes....">D3D12MA::POOL_DESC::BlockSize</a>. When doing this, all <b>resources created in such pool are placed</b> in those blocks (heaps) and never created as committed. Example:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="struct_d3_d12_m_a_1_1_c_p_o_o_l___d_e_s_c.html">D3D12MA::CPOOL_DESC</a> poolDesc = <a class="code hl_struct" href="struct_d3_d12_m_a_1_1_c_p_o_o_l___d_e_s_c.html">D3D12MA::CPOOL_DESC</a>{</div>
<div class="line">    D3D12_HEAP_TYPE_DEFAULT,</div>
<div class="line">    <a class="code hl_define" href="_d3_d12_mem_alloc_8h.html#ac3d50f134ad24c58df4a934b87847653">D3D12MA_RECOMMENDED_HEAP_FLAGS</a> | D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS };</div>
<div class="line">poolDesc.<a class="code hl_variable" href="struct_d3_d12_m_a_1_1_p_o_o_l___d_e_s_c.html#af7284cc51a8ed5b551075584256de23c">BlockSize</a> = 100llu * 1024 * 1024; <span class="comment">// 100 MB. Explicit BlockSize guarantees placed.</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_d3_d12_m_a_1_1_pool.html">D3D12MA::Pool</a>* pool;</div>
<div class="line">HRESULT hr = allocator-&gt;CreatePool(&amp;poolDesc, &amp;pool);</div>
<div class="line"><span class="comment">// Check hr...</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="struct_d3_d12_m_a_1_1_c_a_l_l_o_c_a_t_i_o_n___d_e_s_c.html">D3D12MA::CALLOCATION_DESC</a> allocDesc = <a class="code hl_struct" href="struct_d3_d12_m_a_1_1_c_a_l_l_o_c_a_t_i_o_n___d_e_s_c.html">D3D12MA::CALLOCATION_DESC</a>{ pool };</div>
<div class="line"> </div>
<div class="line">CD3DX12_RESOURCE_DESC resDesc = CD3DX12_RESOURCE_DESC::Buffer(</div>
<div class="line">    90llu * 1024 * 1024); <span class="comment">// 90 MB</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_d3_d12_m_a_1_1_allocation.html">D3D12MA::Allocation</a>* alloc;</div>
<div class="line">ID3D12Resource* res;</div>
<div class="line">hr = allocator-&gt;CreateResource(&amp;allocDesc, &amp;resDesc, D3D12_RESOURCE_STATE_COMMON,</div>
<div class="line">    NULL, &amp;alloc, IID_PPV_ARGS(&amp;res));</div>
<div class="line"><span class="comment">// Check hr...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Even a large buffer like this, filling 90% of the block, was created as placed!</span></div>
<div class="line">assert(alloc-&gt;<a class="code hl_function" href="class_d3_d12_m_a_1_1_allocation.html#adca8d5a82bed492fe7265fcda6e53da2">GetHeap</a>() != NULL);</div>
<div class="ttc" id="aclass_d3_d12_m_a_1_1_allocation_html_adca8d5a82bed492fe7265fcda6e53da2"><div class="ttname"><a href="class_d3_d12_m_a_1_1_allocation.html#adca8d5a82bed492fe7265fcda6e53da2">D3D12MA::Allocation::GetHeap</a></div><div class="ttdeci">ID3D12Heap * GetHeap() const</div><div class="ttdoc">Returns memory heap that the resource is created in.</div></div>
<div class="ttc" id="astruct_d3_d12_m_a_1_1_p_o_o_l___d_e_s_c_html_af7284cc51a8ed5b551075584256de23c"><div class="ttname"><a href="struct_d3_d12_m_a_1_1_p_o_o_l___d_e_s_c.html#af7284cc51a8ed5b551075584256de23c">D3D12MA::POOL_DESC::BlockSize</a></div><div class="ttdeci">UINT64 BlockSize</div><div class="ttdoc">Size of a single heap (memory block) to be allocated as part of this pool, in bytes....</div><div class="ttdef"><b>Definition</b> D3D12MemAlloc.h:933</div></div>
</div><!-- fragment --><p><b>You can request a new resource to be created as placed</b> by using <a class="el" href="namespace_d3_d12_m_a.html#abbad31a7e0b3d09d77f3fb704b77645ea4d6808f27de6d0ae57014ec1f4d54326">D3D12MA::ALLOCATION_FLAG_CAN_ALIAS</a>. This is required especially if you plan to create another resource in the same region of memory, aliasing with your resource - hence the name of this flag.</p>
<p>Note <a class="el" href="namespace_d3_d12_m_a.html#abbad31a7e0b3d09d77f3fb704b77645ea4d6808f27de6d0ae57014ec1f4d54326">D3D12MA::ALLOCATION_FLAG_CAN_ALIAS</a> can be even combined with <a class="el" href="namespace_d3_d12_m_a.html#abbad31a7e0b3d09d77f3fb704b77645ea661a5472dba3dcecc5a2cc92afd25675">D3D12MA::ALLOCATION_FLAG_COMMITTED</a>. In this case, the resource is not created as committed, but it is also not placed as part of a larger heap. What happens instead is that a new heap is created with the exact size required for the resource, and the resource is created in it, placed at offset 0.</p>
<h1><a class="anchor" id="optimal_allocation_resource_alignment"></a>
Resource alignment</h1>
<p>Certain types of resources require certain alignment in memory. An alignment is a requirement for the address or offset to the beginning of the resource to be a multiply of some value, which is always a power of 2. For committed resources, the problem is non-existent, because committed resources have their own implicit heaps where they are created at offset 0, which meets any alignment requirement. For placed resources, D3D12MA takes care of the alignment automatically.</p>
<dl class="section user"><dt>Implementation detail</dt><dd>Default alignment required MSAA textures is <code>D3D12_DEFAULT_MSAA_RESOURCE_PLACEMENT_ALIGNMENT</code> = 4 MB. Default alignment required for buffers and other textures is <code>D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT</code> = 64 KB.</dd></dl>
<p>Because the alignment required for buffers is 64 KB, <b>small buffers</b> can waste a lot of memory in between when created as placed. When such small buffers are created as committed, some graphics drivers are able to pack them better. D3D12MA automatically takes advantage of this by preferring to create small buffers as committed. This heuristics is enabled by default. It is also a tradeoff - it can make the allocation of these buffers slower. It can be disabled for an individual resource by using <a class="el" href="namespace_d3_d12_m_a.html#abbad31a7e0b3d09d77f3fb704b77645eaa3ded8847563c24b4522af0586dbd2cb">D3D12MA::ALLOCATION_FLAG_STRATEGY_MIN_TIME</a> and for the entire allocator by using <a class="el" href="namespace_d3_d12_m_a.html#ad5ae5a5e42b878f2e18ab5d1fbfb9916a15c1ba5fbc182ac927b3011e23e74a72">D3D12MA::ALLOCATOR_FLAG_DONT_PREFER_SMALL_BUFFERS_COMMITTED</a>.</p>
<p>For certain textures that meet a complex set of requirements, special <b>"small alignment"</b> can be applied. Details can be found in Microsoft documentation of the <code>D3D12_RESOURCE_DESC</code> structure. For MSAA textures, the small alignment is <code>D3D12_SMALL_MSAA_RESOURCE_PLACEMENT_ALIGNMENT</code> = 64 KB. For other textures, the small alignment is <code>D3D12_SMALL_RESOURCE_PLACEMENT_ALIGNMENT</code> = 4 KB. D3D12MA uses this feature automatically. Detailed behavior can be disabled or controlled by predefining macro <a class="el" href="_d3_d12_mem_alloc_8h.html#ad04069a2e2bbc53b7d65f85a04a2dcbc" title="When defined to value other than 0, the library will try to use D3D12_SMALL_RESOURCE_PLACEMENT_ALIGNM...">D3D12MA_USE_SMALL_RESOURCE_PLACEMENT_ALIGNMENT</a>.</p>
<p>D3D12 also has a concept of <b>alignment of the entire heap</b>, passed through <code>D3D12_HEAP_DESC::Alignment</code>. This library automatically sets the alignment as small as possible. Unfortunately, any heap that has a chance of hosting an MSAA texture needs to have the alignment set to 4 MB. This problem can be overcome by passing <a class="el" href="namespace_d3_d12_m_a.html#ad5ae5a5e42b878f2e18ab5d1fbfb9916adfbfd20d716f2a46f74d6226056fef1e">D3D12MA::ALLOCATOR_FLAG_MSAA_TEXTURES_ALWAYS_COMMITTED</a> on the creation of the main allocator object and <a class="el" href="namespace_d3_d12_m_a.html#a919d8545365d6b7209a964f2b99936d1acc379a89755438c0f76667783b778baa">D3D12MA::POOL_FLAG_MSAA_TEXTURES_ALWAYS_COMMITTED</a> on the creation of any custom heap that supports textures, not only buffers. With those flags, the alignment of the heaps created by D3D12MA can be lower, but any MSAA textures are created as committed. You should always use these flags in your code unless you really need to create some MSAA textures as placed. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
